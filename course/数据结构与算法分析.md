# 数据结构与算法分析
“程序 = 数据结构 + 算法”
# 1. 绪论
## 1.1 数据结构的研究内容
通常，用计算机解一个问题的步骤
1. 具体问题抽象为数学模型
2. 设计算法
3. 编程、调试、运行

无法用数学公式或方程来描述，是一些“非数值计算”的程序设计问题
如表、树、图
数据结构是一门研究非数值计算的程序设计中计算机的操作对象以及他们之间的关系和操作的学科
## 1.2 基本概念和术语
### 1.2.1 数据：是能输入计算机且能被计算机处理的各种符号的集合。
包括数值型的数据：整数，实数等
非数值型的数据：文字、图像、图形、声音等
### 1.2.2 数据元素和数据项
数据元素是数据等基本单位，在计算机程序中通常作为一个整体进行考虑和处理，也简称为元素，或称为记录、结点或顶点
数据项是构成数据元素的不可分割的最下单位
数据 > 数据元素 > 数据项
### 1.2.3 数据对象
数据对象是性质相同的数据元素的集合，是数据的一个子集
### 1.2.4 数据结构
数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构
包括：
1. 数据元素之间的逻辑关系，也称为逻辑结构
2. 数据元素及其关系在计算机内存中的表示（又称为映象），称为数据的物理结构或数据的存储结构
3. 数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现

逻辑结构与存储结构的关系：
1. 存储结构是逻辑关系的映象和元素本身的映象。 
2. 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
3. 两者综合起来建立了数据元素之间的关系
### 1.2.5 逻辑结构的分类
方法一：
1. 线性结构
   有且仅有一个开始和一个终端结点，并且所有结点最多只有一个直接前驱和一个直接后驱
   例如：线性表、栈、队列、串
2. 非线性结构
   一个结点可能有多个直接前驱和直接后驱
   例如：树、图

方法二：
1. 集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其他关系
2. 线性结构：结构中的数据元素之间存在着一对一的线性关系
3. 树形结构：结构中的数据元素之间存在着一对多的关系
4. 图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系
### 1.2.6 存储结构
1. 顺序存储结构
   用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示
   C语言中用数组来实现顺序存储结构
2. 链式存储结构
   用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示
   C语言中用指针来实现链式存储结构
3. 索引存储结构
   在存储结点信息的同时，还建立附加的索引表
4. 散列存储结构
   根据结点的关键字直接计算出该结点的存储地址
## 1.3 数据类型和抽象数据类型
### 1.3.1 数据类型
在使用高级程序设计语言写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。
一些最基本数据结构可以用数据类型来实现，如数组、字符串等；而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。
高级语言中的数据类型明显的或者隐含的规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作
数据类型的作用：
1. 约束变量或常量的取值范围
2. 约束变量或常量的操作

数据类型：一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称
数据类型 = 值的集合 + 值集合上的一组操作
### 1.3.2 抽象数据类型
是指一个数学模型以及定义在此数学模型上的一组操作
1. 由用户定义，从问题抽象出数据模型（逻辑结构）
2. 还包括定义在数据模型上的一组抽象运算（相关操作）
3. 不考虑计算机内的具体存储结构与运算的具体实现算法

抽象数据类型的形式定义：
抽象数据类型可用（D, S, P）三元组表示
其中：D是数据对象；
     S是D上的关系集；
     P是对D的基本操作集
定义格式如下：
```
ADT 抽象数据类型名{
    数据对象:<数据对象的定义>
    数据关系:<数据关系的定义>
    基本操作:<基本操作的定义>
} ADT 抽象数据类型名
```
其中：
1. 数据对象、数据关系的定义用伪代码描述
2. 基本操作的定义格式为：
   基本操作名（参数表）
   初始条件: <初始条件描述>
   操作结果: <操作结果描述>

基本操作定义格式说明：
1. 参数表：赋值参数，只为操作提供输入值
   引用参数 以&打头，除可提供输入值外，还将返回操作结果
2. 初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应的出错信息。若初始条件为空，则省略之
3. 操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果
## 1.4 算法和算法分析
算法的定义
### 1.4.1算法的描述
- 自然语言：英文，中文
- 流程图：传统流程图、NS流程图
- 伪代码：类语言，类C语言
- 程序代码：C语言程序，JAVA
### 1.4.2 算法与程序
- 算法是解决问题的一种方式或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
- 程序时用某种程序设计语言对算法的具体实现
- 程序 = 数据结构 + 算法
- - 数据结构通过算法实现操作
- - 算法根据数据结构设计程序
### 1.4.3 算法特性
一个算法必须具备以下五个重要特性
- 有穷性 一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
- 确定性 算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同输出
- 可行性 算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入 一个算法有零个或多个输入
- 输出 一个算法有一个或多个输出 
### 1.4.4 算法设计的要求
- 正确性
- 可读性
- 健壮性 鲁棒性
- 高效性
### 1.4.5 算法分析
#### 1.4.5.1 算法效率
算法效率以下两个方面考虑
1. 时间效率：算法所耗费的时间
2. 空间效率：算法执行过程中所耗费的存储空间
#### 1.4.5.2 时间复杂度的度量
时间效率和空间效率有时候是矛盾的
时间效率的度量：依据该算法编制的程序在计算机上所执行消耗的时间
- 事后统计
- - 将算法实现，测量其时间和空间开销
- - 缺点：编写程序实现依赖硬件等误差，影响分析
- 事前分析
- - 对算法所消耗资源的一种估算
- - 简单操作（如赋值、比较、移动等）
- - 算法运行时间 = 一个简单操作所需的时间 * 简单操作次数
- 也就是算法每条语句的执行时间之和
- - 算法运行时间 = 每条语句频度 * 该语句执行所需时间 的求和
- 语句执行时间一般随机器而异的，取决于机器的指令性能、速度以及编译代码的质量
- 故我们可以假设每条语句所需时间均为单位时间，那么只需考虑所有语句的执行次数，即频度之和
#### 1.4.5.3 时间复杂度的定义
算法耗费的时间定义为该算法每条语句的频度之和
为了便于比较不同算法的时间效率，我们仅比较他们的数量级
- 当n区域无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数
- 一般情况下，不必计算所有操作的执行次数，只考虑基本语句的重复执行次数，是个问题规模n的某个函数f(n)，算法的时间量度记为：T(n) = O(f(n))
#### 1.4.5.4 基本语句
n越大算法执行时间越长
- 排序：n为记录数
- 矩阵：n为矩阵的阶数
- 多项式：n为多项式的项数
- 集合：n为元素个数
- 树：n为树的结点个数
- 图：n为图的顶点数或边数
#### 分析算法时间复杂度的基本方法
忽略所有低次幂项和最高次幂系数，体现出增长率的含义
1. 找出语句频度最大的那条语句作为基本语句
2. 计算基本语句的频度得到问题规模n的某个函数f(n)
3. 取其数量级用符号“O”表示

对于出现由输入数据集决定的时间复杂度，有三种情况
- 最坏时间复杂度：指在最坏的情况下，算法的时间复杂度
- 平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间
- 最好时间复杂度：指在最好情况下，时间复杂度

我们一般考虑最坏之间复杂度
#### 时间复杂度的比较
常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 ... k次立方阶 指数阶
尽量设置低阶算法
对树阶 线性阶 平方阶......
不要指数阶，阶乘是不可接受的
#### 渐进空间复杂度
空间复杂度：算法所需存储空间的度量
算法要占据的空间
- 算法本身要占据的空间，输入/输出，指令，常数，变量等
- 算法要使用的辅助空间
#### 设计好算法的过程
抽象数据类型 = 数据的逻辑结构 + 抽象运算（运算的功能描述）
# 2. 线性表
## 2.1 线性表的定义和特点
线性表是具有相同特性的数据元素的一个有限序列
线性起点 数据元素 线性终点
任意一个元素，有直接前驱，直接后驱
下标，是元素的序号，表示元素在表中的位置
### 总结：
- 由n个数据元素组成的有限序列
- 其中数据元素的个数n定义为表的长度
- 当n=0时称为空表
- 将非空的线性表记作：（a1, a2, ...an）
- 这里的数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同

### 逻辑特征
- 在非空的线性表，有且仅有一个开始结点a<sub>1</sub>，他没有直接前趋，而仅有一个直接后趋a<sub>2</sub>
- 有且仅有一个终端结点a<sub>n</sub>，他没有直接后继，而仅有一个直接前趋a<sub>n-1</sub>
- 其余的内部结点a<sub>i</sub>(2<=i<=n-1)都有且仅有一个直接前趋a<sub>i-1</sub>和一个直接后继a<sub>i+1</sub>
- 线性表是一种典型的线性结构
## 2.2 案例引入
### 案例2.1 一元多项式的运算
实现两个多项式加减乘除运算
$$
P_{n}(x)=p_{0}+p_{1}x+p_{2}x^{2}+...+p_{n}x^{n}
$$
线性表$P=(p_{0},p_{1},p_{2},...,p_{n})$
（每一项的指数i隐含在其系数$p_{i}$）的序号中
例如：
$$P(x)=10+5x-4x^{2}+3x^{3}+2x^{4}$$
可以用数组来表示
[10, 5, -4, 3, 2]
#### 加法
$R_{n}(x)=P_{n}(x)+Q_{m}(x)$
线性表$R=(p_{0}+q_{0},p_{1}+q_{1},p_{2}+q_{2},...,p_{m}+q_{m}+p_{m+1},...,p_{n})$
### 案例2.2 稀疏多项式的运算
稀疏多项式：
$S(x)=1+3x^{10000}+2x^{20000}$
需要20001个存储空间，造成很大的浪费
采用稀疏多项式，存储系数和指数
$$P_{n}(x)=p_{1}x^{e1}+p_{2}x^{e2}+...+p_{m}x^{em}$$
得线性表：
$$P=((p_{1},e_{1}),(p_{2},e_{2}),...,(p_{m},e_{m}))$$
假设有两个非零多项式
$A(x)=7+3x+9x^{8}+5x^{17}$
$B(x)=8x+22x^{7}-9x^{8}$
则线性表:
$A=((7,0),(3,1),(9,8),(5,17))$
$B=((8,1),(22,7),(-9,8))$
- 创建一个新的数组c
- 分别从头遍历比较a和b的每一项
  - 指数相同，对应系数相加，若其和不为零，则在c中增加一个新项
  - 指数不相同，则将指数较小的项复制到c中
- 一个多项式已遍历完毕时，将另一个剩余项依次复制到c中即可
### 顺序存储结构存在问题
- 存储空间分配不灵活
- 运算的空间复杂度高
### 总结
- 线性表中数据元素的类型可以是简单类型，也可以是复杂类型
- 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序
- 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型），然后实现其存储结构和基本操作
## 2.3 线性的类型定义
- 抽象数据类型线性表的定义如下：
```c++
ADT List{
   数据对象: D = {ai | ai属于Elemset, (i=1,2,...,n, n>=0)}
   数据关系: R={<ai-1, ai> | ai-1, ai属于D, (i=2,3,...,n)}
   基本操作:
      InitList(&L);  DestroyList(&L);
      ListInsert(&L,i,e); ListDelete(&L,i,&e);
      ......等等
}ADT List
```
- InitList(&L) (Initialization List)
  - 操作结果：构造一个空的线性表L。
- DestroyList(&L)
  - 初始条件：线性表L已经存在
  - 操作结果：销毁线性表L
- ClearList(&L)
  - 初始条件：线性表L已经存在
  - 操作结果：将线性表L重置为空表
- ListEmpty(L)
  - 初始条件：线性表L已经存在
  - 操作结果：若线性表L为空表，则返回TRUE，否则返回FALSE
- ListLength(L)
  - 初始条件：线性表L已经存在
  - 操作结果：返回线性表L中数据元素个数
- GetElem(L,i,&e)
  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
  - 操作结果：用e返回线性表L中第i个数据元素的值
- LocateElem(L,e,compare())
  - 初始条件：线性表L已经存在，compare()是数据元素判定函数
  - 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0
- ProiorElem(L,cur_e,&pre_e)
  - 初始条件：线性表L已经存在
  - 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义
- NextElem(L,cur_e,&next_e)
  - 初始条件：线性表L已经存在
  - 操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义
- ListInsert(&L,i,e)
  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)+1
  - 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加一
    - 插入元素e之前（长度为n）：$(a_{1},a_{2},...,a_{i-1},a_{i},...,a_{n})$
    - 插入元素e之后（长度为n+1）：$(a_{1},a_{2},...,a_{i-1},e,a_{i},...,a_{n})$
- ListDelete(&L,i,&e)
  - 初始条件：线性表L已经存在，1<=i<=ListLength(L)
  - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
    - 删除前（长度为n）: $(a_{1},a_{2},...,a_{i-1},a_{i},a_{i+1},...,a_{n})$
    - 删除后（长度为n-1）: $(a_{1},a_{2},...,a_{i-1},a_{i+1},...,a_{n})$
- ListTraverse(&L,visited())
  - 初始条件：线性表L已经存在
  - 操作结果：依次对线性表中每个元素调用visited()
- 以上所提及的运算是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于“如何做”等实现细节，只有待确定了存储结构之后才考虑
## 2.4 线性表的顺序表示和实现
### 2.4.1 顺序表的顺序存储表示
- 线性表的顺序表示又称为顺序存储结构或顺序映象
- 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
- 线性表的第一个数据元素的存储位置，称作线性表的起始位置或基地址
- 依次存储，地址连续，中间没有空出存储单元

线性表顺序存储结构占用一片连续的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置
- 如果每个元素占用8个存储单元，$a_{i}$存储位置是2000单元，则$a_{i+1}$存储位置是2008单元
- 假设线性表的每个元素需占$l$个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系:
$$LOC(a_{i+1})=LOC(a_{i})+l$$
- 由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：
$$LOC(a_{i})=LOC(a_{1})+(i-1)\times l$$

顺序表的特点：
- 以物理位置相邻表示逻辑关系
- 任一元素均可随机存取
- 元素
  - 地址连续
  - 依次存放
  - 随机存取
  - 类型相同
- 和数组特点一致，用一维数组来表示顺序表
- 线性表长度可变（删除），但数组长度不可动态定义
- 解决方法，用一变量表示顺序表的长度属性
```c++
#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量
typedef struct{
   Element elem[LIST_INIT_SIZE];
   int length; // 当前长度
} SqList;
```

多项式的顺序存储结构类型定义
公式：$P_{n}(x)=p_{1}x^{e_{1}}+p_{2}x^{e_{2}}+...+p_{m}x^{e_{m}}$
线性表：$P=((p1,e1),(p2,e2),...,(pm,em))$
数据结构实现：
```c++
#define MAXSIZE 1000 // 多项式可能达到的最大长度
tyepdef struct{ //多项式非零项的定义
   float p; // 系数
   int e; //指数
} Polynomial;

typedef struct{
   Polynomial* elem; // 存储空间的基位置
   int length; // 多项式中当前项的个数
} SqList; // 多项式的顺序存储结构类型为SqList
```

图书表的顺序存储结构类型的数据结构实现：
```c++
#define MAXSIZE 10000 // 图书表可能到达的最大长度
typedef struct { // 图书信息定义
   char no[20]; // 图书ISBN
   char name[50]; // 图书名字
   float price; // 图书价格
} Book;

typedef struct{
   Bood* elem; // 存储空间的基地址
   int length; // 图书表中当前图书个数
} SqList; // 图书表的顺序存储结构类型为SqList
```
### 补充：数组定义
```c++
// 数组静态分配
typedef struct
{
  ElemType data[MaxSize];
  int length;
} SqList;
// 数组动态分配
typedef struct
{
  ElemType* data;
  int length;
}
SqList L;
L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);
```
### 补充：C语言的内存动态分配
- malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址
- sizeof(x)运算，计算变量x的长度
- free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量
- 需要加载头文件<stdlib.h>
### 补充：C++的内存动态分配
new 类型名T(初值列表)
- 功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值
- 结果值：
  - 成功：T类型的指针，指向新分配的内存
  - 失败：0（NULL）
### 补充：C++中的参数传递
- 函数调用时传送给形参表的实参必须与形参保持三个一致
  - 类型、个数、顺序
- 参数传递有两种方式
  - 传值方式（参数为整型、实型、字符型等）
  - 传地址
    - 参数为指针变量
    - 参数为引用类型
    - 参数为数组名
#### 传值方式
- 把实参的值传送给函数局部工作区相应的副本中，函数使用这个副本执行必要的功能。函数修改的是副本的值，实参的值不变
```c++
#include<iostream>
void swap(float m, float n)
{
  float temp;
  temp = m;
  m = n;
  n = temp;
}
void main()
{
  float a, b;
  cin >> a >> b;
  swap(a, b);
  cout <<a << endl << b << endl;
}
```
#### 传地址方式
传入地址，在函数中修改地址指向的值，则值会改变
```c++
#include<iostream>
void swap(float *m, float *n)
{
  float temp;
  temp = *m;
  *m = *n;
  *n = temp;
}
void main()
{
  float a, b;
  cin >> a >> b;
  swap(&a, &b);
  cout <<a << endl << b << endl;
}
```
- 形参变化不影响实参的情况，此情况下相当于只修改了传入的局部变量的指针的值，而未修改指针指向的值，本质还是值传递
```c++
#include<iostream>
void swap(float *m, float *n)
{
  float *temp;
  temp = m;
  m = n;
  n = temp;
}
void main()
{
  float a, b;
  cin >> a >> b;
  swap(&a, &b);
  cout <<a << endl << b << endl;
}
```
#### 数组名作为参数
- 传递的是数组的首地址
- 对形参数组所做的任何改变都将反映到实参数组中
### 2.4.2 顺序表基本操作的实现
- 线性表的基本操作
  - InitList(&L) //初始化操作，建立一个空的线性表
  - DestroyList(&L) //销毁已存在的线性表L
  - ClearList(&L) //将线性表清空
  - ListInsert(&L, i, e) //在线性表L中第i个位置插入新元素e
  - ListDelete(&L, i, &e) //删除线性表L中的第i个元素，用e返回
  - IsEmpty(L) //若线性表为空，返回true，否则false
  - ListLength(L) //返回线性表L的元素个数
  - LocateElem(L, e) //L中查找与给定值e相等的元素，若成功则返回该元素在表中的序号，否则返回0
  - GetElem(L, i, &e) //将线性表L中的第i个位置元素返回给e
#### 操作算法中用到的预定义常量和类型
```c++
// 函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
// Status 是函数的类型，其值是函数结果状态代码
typedef int Status;
typedef char ElemType;
```
#### 线性表的初始化（参数引用型）
```c++
Status InitList_Sq(SqList &L) // 构造一个空的顺序表
{
  L.elem = new ElemType[MAXSIZE]; // 为顺序表分配空间
  if (!l.elem) exit(OVERFLOW); // 存储分配失败
  L.length = 0;
  return OK;
}
```
#### 线性表的销毁
```c++
void DestroyList(SqList &L)
{
  if (L.elem) delete L.elem; // 释放存储空间
}
```
#### 线性表的清空
```c++
void ClearList(SqList &L)
{
  L.length = 0;
}
```
#### 线性表的长度
```c++
int GetLength(SqList L)
{
  return (L.length);
}
```
#### 判断线性表是否为空
```c++
int isEmpty(SqList L)
{
  if (L.length == 0) return 1;
  else return 0;
}
```
#### 顺序表的取值
```c++
int GetElem(SqList L, int i, ElemType &e)
{
  if (i <1 || i > L.length) return ERROR;
  e = L.elem[i-1];
  return OK;
}
```
#### 顺序表的查找
- 在线性表L中查找与指定值e相同的数据元素的位置
- 从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0
```c++
int LocateElem(SqList L, ElemType e)
{
  for (i = 0; i < L.length; i++)
    if (L.elem[i] == e) return i+1; // 查找成功，返回序号
  return 0; // 查找失败，返回0
}
```
- 平均查找长度 ASL Average Search Length
  - 为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的平均查找长度
  - 对于含有n个记录的表，查找成功时：$$\sum_{i=1}^{n}P_{i}C_{i}$$
#### 顺序表的插入
- 插入不同位置的算法演示
  - 插入位置在最后
    - 1 2 3 4 5 6 7
  - 插入位置在中间
    - 1 2 3 4 7 5 6
  - 插入位置在最前面
    - 7 1 2 3 4 5 6
- 算法思想
  - 判断插入位置i是否合法
  - 判断顺序表的存储空间是否已满，若已满返回ERROR
  - 将第n至第i位的元素依次向后移动一个位置，空出第i个位置
  - 将要插入第新元素e放入第i个位置
  - 表长+1
```c++
Status ListInsert_Sq(SqList &L, int i, ElemType e)
{
  if (i < 1 || i > L.length + 1) return ERROR; // i值不合法
  if (L.length == MAXSIZE) return ERROR; // 当前存储空间已满
  for (j = L.length - 1; j >= i - 1; j--)
  {
    L.elem[j+1] = L.elem[j]; // 插入位置及之后的元素后移
  }
  L.elem[i-1] = e; // 新元素e放入第i个位置
  L.length++; // 表长增1
}
```
- 算法分析：算法时间主要耗费在移动元素的操作上
  - 若插入在尾结点之后，则根本无需移动(特别快)
  - 若插入在首结点之前，则表中元素全部后移(特别慢)
  - 平均次数 - $O(n)$
#### 顺序表的删除
- 删除算法演示
  - 删除位置在最后
    - 1 2 3 4 5
  - 删除位置在中间
    - 1 2 3 5 6
  - 删除位置在最前面
    - 2 3 4 5 6
- 算法思想
  - 判断删除位置i是否合法，1<=i<=n
  - 将欲删除的元素保留在e中
  - 将第i+1至第n位的元素依次向前移动一个位置
  - 表长减1，删除成功返回OK
```c++
Status ListDelete_Sq(SqList &L, int i)
{
  if (i < 1 || i > L.length) return ERROR;
  for (j = i, j <+= L.length - 1; j++)
    L.elem[j-1] = L.elem[j];
  L.length--;
}
return OK;
```
- 算法分析：算法时间主要耗费在移动元素的操作上
  - 若删除尾结点，则根本无需移动
  - 若删除首结点，则表中n-1个元素全部前移
  - 平均次数 - $O(n)$
### 2.4.3 顺序表的特点
- 利用数据元素的存储位置表示线性表中相邻元素之间的前后关系，即线性表的逻辑结构与存储结构一致
- 在访问线性表时，可以快速地计算出任意一个数据元素的存储位置，因此可以粗略地认为，访问每个元素所花时间相等
  - 这种存取元素的方法被称为随机存储法
- 优点
  - 存储密度大(结点本身所占存储量/结点结构所占存储量)
  - 可以随机存取表中任一元素
- 缺点
  - 在插入、删除某一元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素的个数不能自由扩充
## 2.5 线性表的链式表示和实现
### 2.5.1 基本介绍
- 链式存储结构
  - 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻

- 与链式存储有关的术语
  - 结点：数据元素的存储映象。由数据域和指针域两部份组成
  - 链表：n个结点由指针链组成一个链表，它是线性表的链式存储映象，称为线性表的链式存储结构
- 单链表、双链表、循环链表
  - 结点只有一个指针域的链表，称为单链表或线性链表
  - 结点有两个指针域的链表，称为双链表
  - 首位相接的链表称为循环链表
- 头指针、头结点和首元结点
  - 头指针：是指向链表中的第一个结点
  - 首元结点：是指链表中存储第一个数据元素的结点
  - 头结点：是在链表的首结点之前附设的一个结点
- 两种形式
  - 不带头结点 头指针直接指向首元结点
  - 带头结点 头指针指向头结点，头结点的指针指向首元结点
- 问题讨论
  - 如何表示空表
    - 无头结点，头指针为空时，标示空表
    - 有头结点，当头结点的指针域为空，标示空表
  - 在链表中设置头结点有什么好处
    - 便于首元结点的处理：首元结点的地址报存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理
    - 便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了
  - 头结点的数据域内装的是什么
    - 头结点的数据域可以为空，也可以存放线性表长度等附加信息，但统计表长时不能统计此结点
- 链表（链式存储结构）的特点
  - 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
  - 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等
- 带头结点的单链表
  - 单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名，若头指针名是L，则把链表称为表L
### 2.5.2 单链表基本操作的实现
- 单链表的初始化(带头结点的单链表)
  - 生成新结点作为头结点，用头指针L指向头结点
  - 将头结点指针域置空
```c++
Status InitList_L(LinkList &L)
{
  L = new LNode; // L = (LinkList)malloc(sizeof(LNode));
  L->next = NULL;
  return OK;
}
```
- 判断链表是否为空
```c++
int ListEmpty(LinkList L)
{
  if (L->next) // 非空
    return 0;
  else
    return 1;
}
```
- 单链表的销毁
  - 从头指针开始，依次释放所有结点
```c++
Status DestroyList_L(LinkList &L)
{
  Lnode* p; // 或LinkList p;
  while(L)
  {
    p = L;
    L = L->next;
    delete p;
  }
}
```
- 清空链表
  - 链表仍存在，但链表中无元素，成为空链表
```c++
Status ClearList(LinkList &L)
{
  Lnode *p, *q; // LinkList p, q;
  p = L->next;
  while(p)
  {
    q = p->next;
    delete p;
    p = q;
  }
  L->next = NULL;
  return OK;
}
```
- 求单链表的表长
  - 从首元结点开始，依次计数所有结点
```c++
int ListLength_L(LinkList L)
{
  LinkList p;
  p = L->next;
  i = 0;
  while(p)
  {
    i++;
    p = p->next;
  }
  return i;
}
```
- 取值-取单链表中第i个元素的内容
  - 从第一个结点开始，顺链扫描，用指针p指向当前扫描到的结点，p初值=L->next
  - j做计数器，累计当前扫描过的结点数，j初值为1
  - 当p指向扫描到的下一结点时，j++
  - 当j==i时，p所指向的结点就是要找的第i个结点
```c++
Status GetElem_L(LinkList L, int i, ElemType &e)
{
  p = L->next;
  j = 1;
  while(p && j < i)
  {
    p = p->next;
    j++;
  }
  if (!p || j > i) return ERROR;
  e = p->data;
  return OK; 
}
```

## 2.6 顺序表和链表的比较
## 2.7 线性表的应用
## 2.8 案例分析与实现
